<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>English Video Study</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; width:100%; height:100%;
      font-family:'Fredoka',sans-serif;
      background: linear-gradient(to bottom right,#fce4ec,#f3e5f5);
      display:flex; flex-direction:column; overflow:hidden;
    }
    header { padding:10px 20px; background:transparent; display:flex; align-items:center; }
    header h1 { 
      flex:1; margin:0; font-size:20px; color:#880e4f; 
      display: flex; align-items: center;
    }
    header h1 svg {
      margin-right: 10px;
    }
    .top-controls { display:flex; gap:10px; }
    .top-controls button {
      padding:6px 12px; border:none; border-radius:20px;
      background:#f06292; color:#fff; font-size:14px; cursor:pointer;
    }
    .offset-input {
      background:#fff; color:#000; border:1px solid #f06292;
      width:50px; border-radius:20px; text-align:center; padding:6px;
    }
    
    /* Êñ∞Â∏ÉÂ±ÄÊ†∑Âºè */
    .new-layout {
      display: flex;
      padding: 20px;
      gap: 20px;
      height: calc(100vh - 70px);
      overflow: hidden;
    }
    
    .left-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .video-container {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .search-section {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 200px;
      overflow: hidden;
    }
    
    .subtitles-container {
      flex: 1;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .video-wrapper { position:relative; }
    video {
      width:100%; height:48vh; background:#000; border-radius:12px;
      position:relative; z-index:2;
    }
    .current-sub {
      position:absolute; bottom:60px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.6); color:#fff;
      padding:6px 12px; border-radius:4px; font-size:18px; line-height:1.2;
      width:calc(100% - 32px); text-align:center; z-index:3;
      white-space:normal;
    }
    .circle-buttons { display:flex; justify-content:center; gap:12px; margin:16px 0; }
    .circle-buttons button {
      width:50px; height:50px; border:none; border-radius:50%; background:#ff6eb4;
      color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    .circle-buttons button:hover { background:#ff8fcc; }
    #status { color:#6a1b9a; font-size:14px; margin-bottom:12px; }
    
    .search-controls { 
      display:flex; 
      gap:12px; 
      margin-bottom:10px;
    }
    .search-controls input {
      flex:1; 
      padding:12px; 
      border:1px solid #f8bbd0; 
      border-radius:8px; 
      font-size:16px;
    }
    .search-controls button {
      padding:10px 16px; 
      border:none; 
      border-radius:20px;
      background:#f06292; 
      color:#fff; 
      font-size:15px;
    }
    .search-controls button:hover {
      background:#e91e63;
    }
    .search-actions {
      display:flex; 
      gap:10px; 
      margin-top:5px;
    }
    .translation {
      flex: 1;
      padding:16px; 
      background:#fff; 
      border-radius:12px;
      font-size:15px; 
      overflow-y:auto;
      border:1px solid #f8bbd0;
      position: relative;
    }
    
    .translation::before {
      content: "‰∏≠ÊñáËß£Èáä:";
      display: block;
      font-size: 14px;
      color: #880e4f;
      margin-bottom: 8px;
    }
    #subtitles {
      flex:1; overflow-y:auto; border:2px solid #f8bbd0;
      border-radius:12px; padding:8px; font-size:16px;
      height:100%; max-height:100%;
    }
    .subtitle-line {
      padding:8px; margin-bottom:4px; cursor:pointer;
      transition:background 0.2s;
    }
    .subtitle-line.active, .subtitle-line:hover {
      background:#f48fb1; color:#fff;
    }
  </style>
</head>
<body>
  <header>
    <h1>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z" fill="#880e4f"/>
      </svg>
      English Video Study
    </h1>
    <div class="top-controls">
      <button onclick="videoFile.click()">Video</button>
      <button onclick="srtFile.click()">Subtitle</button>
      <input type="number" id="offsetInput" class="offset-input" value="0" step="0.1" title="Offset seconds">
    </div>
  </header>

  <input type="file" id="videoFile" accept="video/mp4,video/webm,video/x-matroska,.mkv" style="display:none">
  <input type="file" id="srtFile" accept=".srt" style="display:none">

  <div class="new-layout">
    <div class="left-panel">
      <div class="video-container">
        <div class="video-wrapper">
          <video id="video" controls></video>
          <div id="currentSub" class="current-sub"></div>
        </div>
        <div class="circle-buttons">
          <button id="prevBtn">&#x23EE;</button>
          <button id="playBtn">&#x25B6;</button>
          <button id="pauseBtn">&#x23F8;</button>
          <button id="nextBtn">&#x23ED;</button>
          <button id="loopBtn">&#x27F3;</button>
          <button id="increaseBtn">A+</button>
          <button id="decreaseBtn">A-</button>
        </div>
        <div id="status">Upload video and subtitle to begin</div>
        <div style="font-size:12px;color:#666;margin-top:8px;">
          ‚å®Ô∏è Âø´Êç∑ÈîÆÔºö‚Üë‰∏ä‰∏ÄÂè• ‚Üì‰∏ã‰∏ÄÂè• Á©∫Ê†ºÊí≠Êîæ/ÊöÇÂÅú
        </div>
      </div>

      <div class="search-section">
        <div class="search-controls">
          <input type="text" id="searchInput" placeholder="Search word...">
          <button id="searchBtn">Search</button>
        </div>
        <div id="translation" class="translation"></div>
      </div>
    </div>
    
    <div class="subtitles-container">
      <div id="subtitles"></div>
    </div>
  </div>

  <script>
    const video = document.getElementById('video'),
          videoFile = document.getElementById('videoFile'),
          srtFile = document.getElementById('srtFile'),
          offsetInput = document.getElementById('offsetInput'),
          subtitlesDiv = document.getElementById('subtitles'),
          currentSub = document.getElementById('currentSub'),
          playBtn = document.getElementById('playBtn'),
          pauseBtn = document.getElementById('pauseBtn'),
          prevBtn = document.getElementById('prevBtn'),
          nextBtn = document.getElementById('nextBtn'),
          loopBtn = document.getElementById('loopBtn'),
          increaseBtn = document.getElementById('increaseBtn'),
          decreaseBtn = document.getElementById('decreaseBtn'),
          statusDiv = document.getElementById('status'),
          searchInput = document.getElementById('searchInput'),
          searchBtn = document.getElementById('searchBtn'),
          translationDiv = document.getElementById('translation');
    let subtitles = [], currentIndex = -1, loopMode = false, fontSize = 18, loopTargetIndex = -1;

    // Load video
    videoFile.onchange = e => {
      const f = e.target.files[0]; if (!f) return;
      video.src = URL.createObjectURL(f);
      video.load();
      video.oncanplay = () => statusDiv.textContent = `üé¨ Video ready: ${f.name}`;
    };

    // Load subtitles
    srtFile.onchange = e => {
      const f = e.target.files[0]; if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        subtitles = parseSRT(r.result);
        renderSubtitles();
        statusDiv.textContent = `üìù Subtitles loaded (${subtitles.length})`;
      };
      r.readAsText(f);
    };

    // Parse SRT into [{start,end,zh,en},...]
    function parseSRT(data) {
      const off = parseFloat(offsetInput.value) || 0;
      const blocks = data.trim().split(/\r?\n\r?\n/);
      const result = [];
      
      console.log('[INFO] Starting SRT parsing, total blocks:', blocks.length);
      
      blocks.forEach((block, blockIndex) => {
        const lines = block.split(/\r?\n/);
        console.log(`[BLOCK ${blockIndex + 1}] Raw content:`, lines);
        
        if (lines.length < 2) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: Not enough lines`);
          return;
        }
        
        // Êü•ÊâæÊó∂Èó¥Ë°å
        let timeLineIndex = -1;
        let timeLine = '';
        
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('-->')) {
            timeLineIndex = i;
            timeLine = lines[i];
            break;
          }
        }
        
        if (timeLineIndex === -1) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No time line found`);
          return;
        }
        
        // Ëß£ÊûêÊó∂Èó¥
        const timeRegex = /(\d+):(\d+):(\d+),(\d+)\s*-->\s*(\d+):(\d+):(\d+),(\d+)/;
        const m = timeLine.match(timeRegex);
        if (!m) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: Invalid time format`);
          return;
        }
        
        const st = +m[1]*3600 + +m[2]*60 + +m[3] + +m[4]/1000 + off;
        const et = +m[5]*3600 + +m[6]*60 + +m[7] + +m[8]/1000 + off;
        
        // Ëé∑ÂèñÊâÄÊúâÂ≠óÂπïÂÜÖÂÆπË°åÔºà‰ªéÊó∂Èó¥Ë°å‰πãÂêéÂºÄÂßãÔºâ
        const contentLines = lines.slice(timeLineIndex + 1)
          .filter(line => line.trim()) // ËøáÊª§Á©∫Ë°å
          .filter(line => !line.includes('{\\')) // ËøáÊª§ASS/SSAÊ†∑ÂºèÊ†áËÆ∞
          .map(line => line.trim());
        
        console.log(`[BLOCK ${blockIndex + 1}] Content lines:`, contentLines);
        
        if (contentLines.length === 0) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No valid content`);
          return;
        }
        
        let zh = '', en = '';
        
        if (contentLines.length === 1) {
          // ÂçïË°åÂÜÖÂÆπÔºöÊ£ÄÊµãÊòØÂê¶‰∏∫‰∏≠Êñá
          const content = contentLines[0];
          if (/[\u4e00-\u9fff]/.test(content)) {
            // ÂåÖÂê´‰∏≠ÊñáÂ≠óÁ¨¶ÔºåÂΩì‰Ωú‰∏≠Êñá
            zh = content;
            en = '';
            console.log(`[BLOCK ${blockIndex + 1}] Chinese only: "${zh}"`);
          } else {
            // Á∫ØËã±Êñá
            zh = '';
            en = content;
            console.log(`[BLOCK ${blockIndex + 1}] English only: "${en}"`);
          }
        } else if (contentLines.length === 2) {
          // ÂèåË°åÂÜÖÂÆπÔºöÁ¨¨‰∏ÄË°å‰∏≠ÊñáÔºåÁ¨¨‰∫åË°åËã±Êñá
          const line1 = contentLines[0];
          const line2 = contentLines[1];
          
          if (/[\u4e00-\u9fff]/.test(line1) && !/[\u4e00-\u9fff]/.test(line2)) {
            // Á¨¨‰∏ÄË°åÊúâ‰∏≠ÊñáÔºåÁ¨¨‰∫åË°åÊó†‰∏≠Êñá -> ÂèåËØ≠Ê†ºÂºè
            zh = line1;
            en = line2;
            console.log(`[BLOCK ${blockIndex + 1}] Bilingual: CN="${zh}" EN="${en}"`);
          } else {
            // ÂÖ∂‰ªñÊÉÖÂÜµÔºöÂêàÂπ∂‰∏∫Ëã±Êñá
            zh = '';
            en = contentLines.join(' ');
            console.log(`[BLOCK ${blockIndex + 1}] Merged English: "${en}"`);
          }
        } else {
          // Â§öË°åÂÜÖÂÆπÔºöÂêàÂπ∂‰∏∫Ëã±Êñá
          zh = '';
          en = contentLines.join(' ');
          console.log(`[BLOCK ${blockIndex + 1}] Multi-line English: "${en}"`);
        }
        
        // Âè™Ë¶ÅÊúâÂÜÖÂÆπÂ∞±Ê∑ªÂä†
        if (zh || en) {
          result.push({
            start: st,
            end: et,
            zh: zh,
            en: en
          });
          console.log(`[BLOCK ${blockIndex + 1}] Added: ${st.toFixed(2)}s-${et.toFixed(2)}s`);
        } else {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No valid content`);
        }
      });
      
      console.log('[SUCCESS] Parsing complete, total subtitles:', result.length);
      return result;
    }

    // Render subtitles (‰∏≠ÊñáÂ∞èÂ≠óÂú®‰∏äÔºåËã±ÊñáÂ§ßÂ≠óÂú®‰∏ã)
    function renderSubtitles() {
      subtitlesDiv.innerHTML = '';
      console.log('Rendering subtitles, total:', subtitles.length);
      
      subtitles.forEach((sub, i) => {
        console.log(`Subtitle ${i+1}: CN="${sub.zh}", EN="${sub.en}"`);
        
        const div = document.createElement('div');
        div.className = 'subtitle-line';
        
        // Ê†πÊçÆÊòØÂê¶Êúâ‰∏≠ÊñáÂÜÖÂÆπÂÜ≥ÂÆöÊòæÁ§∫ÊñπÂºè
        if (sub.zh) {
          // ÂèåËØ≠Â≠óÂπïÔºö‰∏≠ÊñáÂú®‰∏äÔºåËã±ÊñáÂú®‰∏ã
          div.innerHTML = `
            <p style="margin:0;color:#880e4f;font-size:12px;line-height:1.3;">${sub.zh}</p>
            <p style="margin:4px 0 0;color:#333;font-size:24px;font-weight:500;line-height:1.2;">${sub.en}</p>
          `;
        } else {
          // Á∫ØËã±ÊñáÂ≠óÂπïÔºöÂè™ÊòæÁ§∫Ëã±Êñá
          div.innerHTML = `
            <p style="margin:0;color:#333;font-size:24px;font-weight:500;line-height:1.2;">${sub.en}</p>
          `;
        }
        
        div.onclick = () => jump(i);
        subtitlesDiv.appendChild(div);
      });
    }

    // Seek & highlight
    function jump(idx) {
      if (idx < 0 || idx >= subtitles.length) {
        console.log(`[JUMP] Invalid index: ${idx}, valid range: 0-${subtitles.length-1}`);
        return;
      }
      
      console.log(`[JUMP] Jumping to subtitle ${idx+1}`);
      currentIndex = idx;
      video.currentTime = subtitles[idx].start;
      video.play().catch(err => console.log('[ERROR] Play failed:', err));
      highlight();
      
      // Âæ™ÁéØÊ®°Âºè‰∏ãÔºöÂàáÊç¢Âà∞Êñ∞Âè•Â≠êÂêéÁ´ãÂç≥ÂºÄÂßãÂæ™ÁéØ
      if (loopMode) {
        console.log(`[LOOP] Sticking to subtitle ${idx+1} in loop mode`);
        statusDiv.textContent = `üîÑ Sticky loop mode: Subtitle ${idx + 1}`;
      }
    }

    function highlight() {
      const lines = subtitlesDiv.querySelectorAll('.subtitle-line');
      lines.forEach((el,i)=>el.classList.toggle('active', i===currentIndex));
      const active = lines[currentIndex];
      if (active) active.scrollIntoView({behavior:'smooth', block:'center'});

      // Video overlay: Ê†πÊçÆÂ≠óÂπïÁ±ªÂûãÊòæÁ§∫
      if (currentIndex >= 0 && currentIndex < subtitles.length) {
        const sub = subtitles[currentIndex];
        
        if (sub.zh) {
          // ÂèåËØ≠Â≠óÂπïÔºö‰∏≠ÊñáÂú®‰∏ä(Â∞èÂ≠ó)ÔºåËã±ÊñáÂú®‰∏ã(Â§ßÂ≠ó)
          currentSub.innerHTML = `
            <div style="line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.8);">
              <div style="font-size:${Math.floor(fontSize*0.6)}px; color:#f8bbd0;">${sub.zh}</div>
              <div style="font-size:${fontSize}px; color:#fff; font-weight:500;">${sub.en}</div>
            </div>
          `;
        } else {
          // Á∫ØËã±ÊñáÂ≠óÂπïÔºöÂè™ÊòæÁ§∫Ëã±Êñá
          currentSub.innerHTML = `
            <div style="line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.8);">
              <div style="font-size:${fontSize}px; color:#fff; font-weight:500;">${sub.en}</div>
            </div>
          `;
        }
      }
    }

    video.ontimeupdate = () => {
      const t = video.currentTime;
      
      // üîÑ Âæ™ÁéØÊ®°ÂºèÔºöALWAYSÂæ™ÁéØÂΩìÂâçÂè•Â≠êÔºå‰∏çÁÆ°ÊÄé‰πàÂàáÊç¢
      if (loopMode && currentIndex >= 0 && currentIndex < subtitles.length) {
        const currentSub = subtitles[currentIndex];
        
        // ÂΩìÂâçÂè•Â≠êÊí≠ÊîæÁªìÊùüÊó∂ÔºåÁ´ãÂç≥Ë∑≥ÂõûÂºÄÂßãÁªßÁª≠Âæ™ÁéØ
        if (t >= currentSub.end - 0.05) {
          console.log(`[LOOP] End detected: ${t.toFixed(2)} >= ${currentSub.end.toFixed(2)}, jumping to start ${currentSub.start.toFixed(2)}`);
          video.currentTime = currentSub.start;
          return; // Âæ™ÁéØË∑≥ËΩ¨Âêé‰∏çÊâßË°åÂÖ∂‰ªñÈÄªËæë
        }
        
        // Âæ™ÁéØÊ®°Âºè‰∏ãÔºöÂ¶ÇÊûúÊí≠Êîæ‰ΩçÁΩÆ‰∏çÂú®ÂΩìÂâçÂè•Â≠êËåÉÂõ¥ÂÜÖÔºåÂº∫Âà∂Ë∑≥Âõû
        if (t < currentSub.start - 0.2 || t > currentSub.end + 0.2) {
          console.log(`[LOOP] Out of range: current=${t.toFixed(2)}, valid=${currentSub.start.toFixed(2)}-${currentSub.end.toFixed(2)}, forcing return`);
          video.currentTime = currentSub.start;
          return;
        }
      } else {
        // Ê≠£Â∏∏Ê®°ÂºèÔºöËá™Âä®Ë∑üÈöèÂ≠óÂπï
        const idx = subtitles.findIndex(s=>t>=s.start&&t<s.end);
        if (idx!==-1 && idx!==currentIndex) {
          console.log(`[AUTO] Changing subtitle to ${idx+1}`);
          currentIndex = idx;
          highlight();
        }
      }
    };

    // Controls
    prevBtn.onclick  = () => jump(Math.max(0, currentIndex-1));
    nextBtn.onclick  = () => jump(Math.min(subtitles.length-1, currentIndex+1));
    playBtn.onclick  = () => {
      video.play();
      if (loopMode && currentIndex >= 0) {
        statusDiv.textContent = `üîÑ Sticky loop mode: Subtitle ${currentIndex + 1}`;
      } else {
        statusDiv.textContent = '‚ñ∂Ô∏è Playing...';
      }
    };
    pauseBtn.onclick = () => {
      if (video.paused) {
        video.play();
        if (loopMode && currentIndex >= 0) {
          statusDiv.textContent = `üîÑ Sticky loop mode: Subtitle ${currentIndex + 1}`;
        } else {
          statusDiv.textContent = '‚ñ∂Ô∏è Playing...';
        }
      } else {
        video.pause();
        statusDiv.textContent = '‚è∏Ô∏è Paused';
      }
    };
    loopBtn.onclick  = () => {
      loopMode = !loopMode;
      
      console.log(`[LOOP] Loop mode ${loopMode ? 'ENABLED' : 'DISABLED'}`);
      
      if (loopMode) {
        // üîÑ ÂºÄÂêØÁ≤òÊÄßÂæ™ÁéØÊ®°Âºè - ÁÆÄÊ¥ÅÊ∑±Ëâ≤Âä†Á≤óÊïàÊûú
        loopBtn.style.backgroundColor = '#d81b60'; // Êõ¥Ê∑±ÁöÑÁ≤âËâ≤
        loopBtn.style.fontWeight = 'bold';
        loopBtn.style.transform = 'none';
        loopBtn.style.boxShadow = 'none';
        loopBtn.innerHTML = '&#x27F3;'; // ‰øùÊåÅ‰∏ÄËá¥ÁöÑÂõæÊ†á
        
        if (currentIndex >= 0 && currentIndex < subtitles.length) {
          // Ë∑≥ËΩ¨Âà∞ÂΩìÂâçÂ≠óÂπïÁöÑÂºÄÂßã‰ΩçÁΩÆ
          console.log(`[LOOP] Resetting current subtitle ${currentIndex+1} to start time`);
          video.currentTime = subtitles[currentIndex].start;
          statusDiv.textContent = `üîÑ Loop mode: Subtitle ${currentIndex + 1}`;
        } else {
          statusDiv.textContent = 'üîÑ Loop mode enabled';
        }
      } else {
        // ÂÖ≥Èó≠Âæ™ÁéØÊ®°Âºè - ÊÅ¢Â§çÊ≠£Â∏∏Áä∂ÊÄÅ
        loopBtn.style.backgroundColor = '#ff6eb4'; // ÂéüÊù•ÁöÑÁ≤âËâ≤
        loopBtn.style.fontWeight = 'normal';
        loopBtn.style.transform = 'none';
        loopBtn.style.boxShadow = 'none';
        loopBtn.innerHTML = '&#x27F3;';
        statusDiv.textContent = 'Loop mode disabled';
      }
    };
    increaseBtn.onclick = ()=>{
      fontSize += 2;
      currentSub.style.fontSize = fontSize+'px';
    };
    decreaseBtn.onclick = ()=>{
      if (fontSize>10) fontSize -= 2, currentSub.style.fontSize = fontSize+'px';
    };

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      // Èò≤Ê≠¢Âú®ËæìÂÖ•Ê°Ü‰∏≠Ëß¶Âèë
      if (e.target.tagName === 'INPUT') return;
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          // ‰∏ä‰∏ÄÂè•
          if (currentIndex > 0) {
            jump(currentIndex - 1);
          }
          break;
        case 'ArrowDown':
          e.preventDefault();
          // ‰∏ã‰∏ÄÂè•
          if (currentIndex < subtitles.length - 1) {
            jump(currentIndex + 1);
          }
          break;
        case ' ':
          e.preventDefault();
          // Á©∫Ê†ºÈîÆÊí≠Êîæ/ÊöÇÂÅúÂàáÊç¢
          if (video.paused) {
            video.play();
            if (loopMode && currentIndex >= 0) {
              statusDiv.textContent = `üîÑ Sticky loop mode: Subtitle ${currentIndex + 1}`;
            } else {
              statusDiv.textContent = '‚ñ∂Ô∏è Playing...';
            }
          } else {
            video.pause();
            statusDiv.textContent = '‚è∏Ô∏è Paused';
          }
          break;
      }
    });

    // Ê∑ªÂä†ÂõûËΩ¶ÈîÆÊêúÁ¥¢ÂäüËÉΩ
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchBtn.click();
      }
    });

    // ÈáçÂÜôÊêúÁ¥¢ÂäüËÉΩ - ÂÖàÊú¨Âú∞ËØçÂÖ∏ÔºåÂêéAPI
    searchBtn.onclick = function() {
      const word = searchInput.value.trim().toLowerCase();
      if (!word) return;
      
      console.log(`[SEARCH] ÊêúÁ¥¢ÂçïËØç: "${word}"`);
      
      // ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
      translationDiv.innerHTML = `<div style=\"margin-bottom:10px;\"><p>üîç Ê≠£Âú®Êü•ËØ¢...</p></div>`;
      
      // ‰ºòÂÖàÊú¨Âú∞ËØçÂÖ∏
      if (commonWords[word]) {
        showTranslation(word, commonWords[word], phonetics[word] || "");
        return;
      }
      // Êú¨Âú∞Ê≤°ÊúâÔºåÂ∞ùËØïÂú®Á∫øAPI
      // ÂÖàMyMemoryÔºåÂÜçDictionaryAPI
      fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|zh-CN`)
        .then(res => res.json())
        .then(data => {
          let translation = '';
          if (data && data.responseData && data.responseData.translatedText) {
            translation = data.responseData.translatedText;
            if (translation.includes('MyMemory')) {
              translation = translation.split('MyMemory')[0].trim();
            }
          }
          if (translation && translation !== word) {
            showTranslation(word, [translation], '');
          } else {
            // ÂÜçËØï DictionaryAPI
            fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
              .then(r => r.json())
              .then(dictData => {
                let phonetic = '';
                let defs = [];
                if (Array.isArray(dictData) && dictData.length > 0) {
                  if (dictData[0].phonetics && dictData[0].phonetics.length > 0) {
                    const p = dictData[0].phonetics.find(x => x.text);
                    if (p) phonetic = p.text;
                  }
                  if (dictData[0].meanings && dictData[0].meanings.length > 0) {
                    dictData[0].meanings.forEach(m => {
                      if (m.definitions && m.definitions.length > 0) {
                        defs.push(m.definitions[0].definition);
                      }
                    });
                  }
                }
                if (defs.length > 0) {
                  showTranslation(word, defs, phonetic);
                } else {
                  showTranslation(word, [], phonetic);
                }
              })
              .catch(() => showTranslation(word, [], ''));
          }
        })
        .catch(() => {
          // APIÂ§±Ë¥•ÔºåÁõ¥Êé•ÊòæÁ§∫Êó†ÁªìÊûú
          showTranslation(word, [], '');
        });
    };

    // Â±ïÁ§∫ÁøªËØëÂíåÈü≥Ê†áÔºåË∞ÉÊï¥Ë°åÈó¥Ë∑ù
    function showTranslation(word, translations, phonetic) {
      let result = `<div style=\"padding:15px;\">`;
      result += `<div style=\"display:flex;align-items:center;margin-bottom:10px;\">
        <h3 style=\"margin:0;font-size:22px;color:#d81b60;\">${word}</h3>
        <span style=\"margin-left:10px;color:#666;font-size:15px;\">${phonetic || ''}</span>
        <button id=\"pronounceBtn\" style=\"margin-left:auto;background:#9c27b0;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;\">
          üîä ÂèëÈü≥
        </button>
      </div>`;
      result += `<h4 style=\"margin:0 0 8px 0;color:#d81b60;font-size:15px;\">‰∏≠ÊñáËß£Èáä:</h4>`;
      if (translations && translations.length > 0) {
        result += `<ol style=\"margin:0;padding-left:22px;line-height:1.5;\">`;
        translations.forEach(function(trans) {
          result += `<li style=\"margin-bottom:5px;font-size:15px;font-weight:500;line-height:1.5;\">${trans}</li>`;
        });
        result += `</ol>`;
      } else {
        result += `<p style=\"color:#666;line-height:1.5;\">Êú™ÊâæÂà∞\"${word}\"ÁöÑÂ∏∏Áî®ÁøªËØëÂíåÈü≥Ê†á„ÄÇ</p>`;
        result += `<p style=\"color:#666;font-size:13px;line-height:1.5;\">ÊèêÁ§∫ÔºöÂ∞ùËØïÊêúÁ¥¢Â∏∏Áî®ÂçïËØçÔºåÂ¶Ç run, get, make, take Á≠â„ÄÇ</p>`;
      }
      result += `</div>`;
      translationDiv.innerHTML = result;
      document.getElementById('pronounceBtn').onclick = function() {
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
      };
    }

    // Â∏∏Áî®Ëã±ËØ≠ÂçïËØçËØçÂÖ∏Êï∞ÊçÆ
    const commonWords = {
      "run": ["Ë∑ëÔºåÂ•îË∑ë", "ËøêË°åÔºåÂºÄÂä®", "ÁÆ°ÁêÜÔºåÁªèËê•"],
      "set": ["ËÆæÁΩÆÔºåÊîæÁΩÆ", "‰∏ÄÂ•óÔºå‰∏ÄÁªÑ", "Âõ∫ÂÆöÁöÑÔºå‰∏çÂèòÁöÑ"],
      "go": ["ÂéªÔºåÁ¶ªÂºÄ", "ËøõË°åÔºåËøõÂ±ï", "Â∞ùËØïÔºåÂä™Âäõ"],
      "make": ["Âà∂‰ΩúÔºåÂàõÈÄ†", "‰ΩøÂæóÔºå‰øÉ‰Ωø", "Ëé∑ÂæóÔºåËµöÂæó"],
      "take": ["ÊãøÔºåÂèñ", "Êé•Âèó", "Ëä±Ë¥πÔºàÊó∂Èó¥Ôºâ"],
      "come": ["Êù•ÔºåÊù•Âà∞", "Âá∫Áé∞", "ÂèëÁîü"],
      "get": ["ÂæóÂà∞ÔºåËé∑Âæó", "ÂèòÂæó", "Âà∞Ëææ"],
      "give": ["Áªô‰∫à", "ÈÄíÁªô", "‰∏æË°åÔºå‰∏æÂäû"],
      "see": ["ÁúãËßÅ", "ÁêÜËß£", "ÊãúËÆø"],
      "look": ["ÁúãÔºåÊ≥®ËßÜ", "ÁúãËµ∑Êù•", "ÂØªÊâæ"],
      "find": ["ÂèëÁé∞", "Êü•Êòé", "ÊÑüËßâÔºåËÆ§‰∏∫"],
      "say": ["ËØ¥", "Ë°®Ëææ", "ÂÅáËÆæ"],
      "use": ["‰ΩøÁî®", "Ê∂àËÄó", "‰π†ÊÉØ"],
      "tell": ["ÂëäËØâ", "Ëæ®Âà´", "ÂëΩ‰ª§"],
      "work": ["Â∑•‰Ωú", "ËøêËΩ¨", "Ëµ∑‰ΩúÁî®"],
      "call": ["ÊâìÁîµËØù", "Âè´Âñä", "ÂëΩÂêç"],
      "try": ["Â∞ùËØï", "ËØïÂõæ", "ÂÆ°Âà§"],
      "ask": ["ÈóÆ", "Ë¶ÅÊ±Ç", "ÈÇÄËØ∑"],
      "need": ["ÈúÄË¶Å", "ÂøÖÈ°ª", "Ë¥´Âõ∞"],
      "feel": ["ÊÑüËßâ", "Êë∏ÔºåËß¶", "ËÆ§‰∏∫"],
      "read": ["ÈòÖËØª", "ÁêÜËß£", "ÊòæÁ§∫ÔºàÊï∞ÂÄºÔºâ"],
      "put": ["ÊîæÔºåÁΩÆ", "Ë°®Ëææ", "ÊèêÂá∫"],
      "play": ["Áé©", "Êí≠Êîæ", "ÊºîÂ•è"],
      "move": ["ÁßªÂä®", "Êê¨ÂÆ∂", "ÊÑüÂä®"],
      "help": ["Â∏ÆÂä©", "ÊîπÂñÑ", "ÈÅøÂÖç"],
      "talk": ["Ë∞àËØù", "ËÆ®ËÆ∫", "ÊºîËÆ≤"],
      "turn": ["ËΩ¨Âä®", "ÂèòÊàê", "ËΩÆÊµÅ"],
      "start": ["ÂºÄÂßã", "ÂàõÂäû", "ÂêØÂä®"],
      "show": ["Â±ïÁ§∫", "Ë°®Êòé", "ËØÅÊòé"],
      "hear": ["Âê¨ËßÅ", "ÂæóÁü•", "ÂÆ°ÁêÜ"],
      "walk": ["Ê≠•Ë°å", "ÈÅõÔºàÁãóÔºâ", "Êº´Ê≠•"],
      "write": ["ÂÜô", "ÂÜô‰Ωú", "ÂºÄÔºàÊîØÁ•®Á≠âÔºâ"],
      "sit": ["Âùê", "ÊãÖ‰ªª", "ÂºÄ‰ºö"],
      "stand": ["Á´ôÁ´ã", "‰Ωç‰∫é", "ÂøçÂèó"],
      "lose": ["Â§±Âéª", "ËæìÊéâ", "ÈîôËøá"],
      "pay": ["‰ªòÊ¨æ", "Áªô‰∫à", "ÂÄºÂæó"],
      "meet": ["ÈÅáËßÅ", "Êª°Ë∂≥", "ËøéÊé•"],
      "drive": ["È©æÈ©∂", "È©±‰Ωø", "ÂºÄËΩ¶ÈÄÅ"],
      "stop": ["ÂÅúÊ≠¢", "ÈòªÊ≠¢", "ÈÄóÁïô"],
      "follow": ["Ë∑üÈöè", "ÈÅµÂæ™", "ÁêÜËß£"],
      "learn": ["Â≠¶‰π†", "ÂæóÁü•", "ËÆ∞‰Ωè"],
      "speak": ["ËØ¥ËØù", "ÊºîËÆ≤", "Ë°®Ëææ"],
      "let": ["ËÆ©", "ÂÖÅËÆ∏", "Âá∫Áßü"],
      "keep": ["‰øùÊåÅ", "ÁªßÁª≠", "È•≤ÂÖª"],
      "leave": ["Á¶ªÂºÄ", "ÈÅóÁïô", "ÂßîÊâò"],
      "break": ["ÊâìÁ†¥", "‰ºëÊÅØ", "Á™ÅÁ†¥"],
      "like": ["ÂñúÊ¨¢", "ÂÉèÔºåÂ¶ÇÂêå", "‰æãÂ¶Ç"],
      "think": ["ÊÄùËÄÉ", "ËÆ§‰∏∫", "ÊÉ≥Ë±°"],
      "want": ["ÊÉ≥Ë¶Å", "ÈúÄË¶Å", "Áº∫‰πè"],
      "open": ["ÊâìÂºÄ", "ÂºÄÂßã", "Âù¶ÁéáÁöÑ"],
      "close": ["ÂÖ≥Èó≠", "Èù†Ëøë", "ÁªìÊùü"],
      "good": ["Â•ΩÁöÑ", "ÊúâÁõäÁöÑ", "ÁÜüÁªÉÁöÑ"],
      "bad": ["ÂùèÁöÑ", "ÊúâÂÆ≥ÁöÑ", "‰∏çËàíÊúçÁöÑ"],
      "big": ["Â§ßÁöÑ", "ÈáçË¶ÅÁöÑ", "ÊàêÂäüÁöÑ"],
      "small": ["Â∞èÁöÑ", "‰∏çÈáçË¶ÅÁöÑ", "Áã≠Á™ÑÁöÑ"],
      "high": ["È´òÁöÑ", "È´òÁ∫ßÁöÑ", "È´ò‰ª∑ÁöÑ"],
      "low": ["‰ΩéÁöÑ", "‰ΩéÁ∫ßÁöÑ", "‰Ωé‰ª∑ÁöÑ"],
      "long": ["ÈïøÁöÑ", "ÊåÅ‰πÖÁöÑ", "ÂÜóÈïøÁöÑ"],
      "short": ["Áü≠ÁöÑ", "ÁÆÄÊ¥ÅÁöÑ", "Áº∫‰πèÁöÑ"],
      "hard": ["Á°¨ÁöÑ", "Âõ∞ÈöæÁöÑ", "Âä™ÂäõÂú∞"],
      "easy": ["ÂÆπÊòìÁöÑ", "ËàíÈÄÇÁöÑ", "ÈöèÂíåÁöÑ"],
      "fast": ["Âø´ÁöÑ", "ËøÖÈÄüÁöÑ", "ÂùöÂõ∫ÁöÑ"],
      "slow": ["ÊÖ¢ÁöÑ", "ÁºìÊÖ¢ÁöÑ", "ËøüÈíùÁöÑ"],
      "hot": ["ÁÉ≠ÁöÑ", "Ëæ£ÁöÑ", "ÊµÅË°åÁöÑ"],
      "cold": ["ÂÜ∑ÁöÑ", "ÂÜ∑Ê∑°ÁöÑ", "ÊÑüÂÜí"],
      "new": ["Êñ∞ÁöÑ", "ÊúÄËøëÁöÑ", "‰∏çÁÜüÊÇâÁöÑ"],
      "old": ["ÊóßÁöÑ", "Âπ¥ËÄÅÁöÑ", "Âè§ËÄÅÁöÑ"],
      "right": ["Ê≠£Á°ÆÁöÑ", "Âè≥ËæπÁöÑ", "ÊùÉÂà©"],
      "wrong": ["ÈîôËØØÁöÑ", "‰∏çÈÄÇÂΩìÁöÑ", "‰∏çÂÖ¨Ê≠£ÁöÑ"],
      "early": ["Êó©ÁöÑ", "ÊèêÂâçÁöÑ", "ÂàùÊúüÁöÑ"],
      "late": ["ÊôöÁöÑ", "ËøüÂà∞ÁöÑ", "Â∑≤ÊïÖÁöÑ"],
      "strong": ["Âº∫Â£ÆÁöÑ", "Âº∫ÁÉàÁöÑ", "ÂùöÂõ∫ÁöÑ"],
      "weak": ["Âº±ÁöÑ", "ËôöÂº±ÁöÑ", "Á®ÄËñÑÁöÑ"],
      "happy": ["Âø´‰πêÁöÑ", "Êª°ÊÑèÁöÑ", "Âπ∏ËøêÁöÑ"],
      "sad": ["ÊÇ≤‰º§ÁöÑ", "‰ª§‰∫∫Â§±ÊúõÁöÑ", "ÈöæËøáÁöÑ"]
    };

    // Ê∑ªÂä†Èü≥Ê†áÊï∞ÊçÆ
    const phonetics = {
      "run": "/r ån/",
      "set": "/set/",
      "go": "/…°…ô ä/",
      "make": "/me…™k/",
      "take": "/te…™k/",
      "come": "/k åm/",
      "get": "/…°et/",
      "give": "/…°…™v/",
      "see": "/siÀê/",
      "look": "/l äk/",
      "find": "/fa…™nd/",
      "say": "/se…™/",
      "use": "/juÀêz/",
      "tell": "/tel/",
      "work": "/w…úÀêk/",
      "call": "/k…îÀêl/",
      "try": "/tra…™/",
      "ask": "/…ëÀêsk/",
      "need": "/niÀêd/",
      "feel": "/fiÀêl/",
      "read": "/riÀêd/",
      "put": "/p ät/",
      "play": "/ple…™/",
      "move": "/muÀêv/",
      "help": "/help/",
      "talk": "/t…îÀêk/",
      "turn": "/t…úÀên/",
      "start": "/st…ëÀêt/",
      "show": "/ É…ô ä/",
      "hear": "/h…™…ô/",
      "walk": "/w…îÀêk/",
      "write": "/ra…™t/",
      "sit": "/s…™t/",
      "stand": "/st√¶nd/",
      "lose": "/luÀêz/",
      "pay": "/pe…™/",
      "meet": "/miÀêt/",
      "drive": "/dra…™v/",
      "stop": "/st…íp/",
      "follow": "/Ààf…íl…ô ä/",
      "learn": "/l…úÀên/",
      "speak": "/spiÀêk/",
      "let": "/let/",
      "keep": "/kiÀêp/",
      "leave": "/liÀêv/",
      "break": "/bre…™k/",
      "like": "/la…™k/",
      "think": "/Œ∏…™≈ãk/",
      "want": "/w…ínt/",
      "open": "/Àà…ô äp…ôn/",
      "close": "/kl…ô äz/",
      "good": "/…° äd/",
      "bad": "/b√¶d/",
      "big": "/b…™…°/",
      "small": "/sm…îÀêl/",
      "high": "/ha…™/",
      "low": "/l…ô ä/",
      "long": "/l…í≈ã/",
      "short": "/ É…îÀêt/",
      "hard": "/h…ëÀêd/",
      "easy": "/ÀàiÀêzi/",
      "fast": "/f…ëÀêst/",
      "slow": "/sl…ô ä/",
      "hot": "/h…ít/",
      "cold": "/k…ô äld/",
      "new": "/njuÀê/",
      "old": "/…ô äld/",
      "right": "/ra…™t/",
      "wrong": "/r…í≈ã/",
      "early": "/Àà…úÀêli/",
      "late": "/le…™t/",
      "strong": "/str…í≈ã/",
      "weak": "/wiÀêk/",
      "happy": "/Ààh√¶pi/",
      "sad": "/s√¶d/"
    };
  </script>
</body>
</html> 