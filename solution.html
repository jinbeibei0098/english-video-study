<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>English Video Study</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; width:100%; height:100%;
      font-family:'Fredoka',sans-serif;
      background: linear-gradient(to bottom right,#fce4ec,#f3e5f5);
      display:flex; flex-direction:column; overflow:hidden;
    }
    header { padding:10px 20px; background:transparent; display:flex; align-items:center; }
    header h1 { 
      flex:1; margin:0; font-size:20px; color:#880e4f; 
      display: flex; align-items: center;
    }
    header h1 svg {
      margin-right: 10px;
    }
    .top-controls { display:flex; gap:10px; }
    .top-controls button {
      padding:6px 12px; border:none; border-radius:20px;
      background:#f06292; color:#fff; font-size:14px; cursor:pointer;
    }
    .offset-input {
      background:#fff; color:#000; border:1px solid #f06292;
      width:50px; border-radius:20px; text-align:center; padding:6px;
    }
    
    /* æ–°å¸ƒå±€æ ·å¼ */
    .new-layout {
      display: flex;
      padding: 20px;
      gap: 20px;
      height: calc(100vh - 70px);
      overflow: hidden;
    }
    
    .left-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .video-container {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .search-section {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 200px;
      overflow: hidden;
    }
    
    .subtitles-container {
      flex: 1;
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .video-wrapper { position:relative; }
    video {
      width:100%; height:48vh; background:#000; border-radius:12px;
      position:relative; z-index:2;
    }
    .current-sub {
      position:absolute; bottom:60px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.6); color:#fff;
      padding:6px 12px; border-radius:4px; font-size:18px; line-height:1.2;
      width:calc(100% - 32px); text-align:center; z-index:3;
      white-space:normal;
    }
    .circle-buttons { display:flex; justify-content:center; gap:12px; margin:16px 0; }
    .circle-buttons button {
      width:50px; height:50px; border:none; border-radius:50%; background:#ff6eb4;
      color:#fff; font-size:20px; display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    .circle-buttons button:hover { background:#ff8fcc; }
    #status { color:#6a1b9a; font-size:14px; margin-bottom:12px; }
    
    .search-controls { 
      display:flex; 
      gap:12px; 
      margin-bottom:10px;
    }
    .search-controls input {
      flex:1; 
      padding:12px; 
      border:1px solid #f8bbd0; 
      border-radius:8px; 
      font-size:16px;
    }
    .search-controls button {
      padding:10px 16px; 
      border:none; 
      border-radius:20px;
      background:#f06292; 
      color:#fff; 
      font-size:15px;
    }
    .search-controls button:hover {
      background:#e91e63;
    }
    .search-actions {
      display:flex; 
      gap:10px; 
      margin-top:5px;
    }
    .translation {
      flex: 1;
      padding:16px; 
      background:#fff; 
      border-radius:12px;
      font-size:15px; 
      overflow-y:auto;
      border:1px solid #f8bbd0;
      position: relative;
    }
    
    .translation::before {
      content: "ä¸­æ–‡è§£é‡Š:";
      display: block;
      font-size: 14px;
      color: #880e4f;
      margin-bottom: 8px;
    }
    #subtitles {
      flex:1; overflow-y:auto; border:2px solid #f8bbd0;
      border-radius:12px; padding:8px; font-size:16px;
      height:100%; max-height:100%;
    }
    .subtitle-line {
      padding:8px; margin-bottom:4px; cursor:pointer;
      transition:background 0.2s;
    }
    .subtitle-line.active, .subtitle-line:hover {
      background:#f48fb1; color:#fff;
    }
  </style>
</head>
<body>
  <header>
    <h1>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z" fill="#880e4f"/>
      </svg>
      English Video Study
    </h1>
    <div class="top-controls">
      <button onclick="videoFile.click()">Video</button>
      <button onclick="srtFile.click()">Subtitle</button>
      <input type="number" id="offsetInput" class="offset-input" value="0" step="0.1" title="Offset seconds">
    </div>
  </header>

  <input type="file" id="videoFile" accept="video/mp4,video/webm,video/x-matroska,.mkv" style="display:none">
  <input type="file" id="srtFile" accept=".srt" style="display:none">

  <div class="new-layout">
    <div class="left-panel">
      <div class="video-container">
        <div class="video-wrapper">
          <video id="video" controls></video>
          <div id="currentSub" class="current-sub"></div>
        </div>
        <div class="circle-buttons">
          <button id="prevBtn">&#x23EE;</button>
          <button id="playBtn">&#x25B6;</button>
          <button id="pauseBtn">&#x23F8;</button>
          <button id="nextBtn">&#x23ED;</button>
          <button id="loopBtn">&#x27F3;</button>
          <button id="increaseBtn">A+</button>
          <button id="decreaseBtn">A-</button>
        </div>
        <div id="status">Upload video and subtitle to begin</div>
        <div style="font-size:12px;color:#666;margin-top:8px;">
          âŒ¨ï¸ å¿«æ·é”®ï¼šâ†‘ä¸Šä¸€å¥ â†“ä¸‹ä¸€å¥ ç©ºæ ¼æ’­æ”¾/æš‚åœ
        </div>
      </div>

      <div class="search-section">
        <div class="search-controls">
          <input type="text" id="searchInput" placeholder="Search word...">
          <button id="searchBtn">Search</button>
        </div>
        <div id="translation" class="translation"></div>
      </div>
    </div>
    
    <div class="subtitles-container">
      <div id="subtitles"></div>
    </div>
  </div>

  <script>
    const video = document.getElementById('video'),
          videoFile = document.getElementById('videoFile'),
          srtFile = document.getElementById('srtFile'),
          offsetInput = document.getElementById('offsetInput'),
          subtitlesDiv = document.getElementById('subtitles'),
          currentSub = document.getElementById('currentSub'),
          playBtn = document.getElementById('playBtn'),
          pauseBtn = document.getElementById('pauseBtn'),
          prevBtn = document.getElementById('prevBtn'),
          nextBtn = document.getElementById('nextBtn'),
          loopBtn = document.getElementById('loopBtn'),
          increaseBtn = document.getElementById('increaseBtn'),
          decreaseBtn = document.getElementById('decreaseBtn'),
          statusDiv = document.getElementById('status'),
          searchInput = document.getElementById('searchInput'),
          searchBtn = document.getElementById('searchBtn'),
          translationDiv = document.getElementById('translation');
    let subtitles = [], currentIndex = -1, loopMode = false, fontSize = 18, loopTargetIndex = -1;

    // Load video
    videoFile.onchange = e => {
      const f = e.target.files[0]; if (!f) return;
      video.src = URL.createObjectURL(f);
      video.load();
      video.oncanplay = () => statusDiv.textContent = `ğŸ¬ Video ready: ${f.name}`;
    };

    // Load subtitles
    srtFile.onchange = e => {
      const f = e.target.files[0]; if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        subtitles = parseSRT(r.result);
        renderSubtitles();
        statusDiv.textContent = `ğŸ“ Subtitles loaded (${subtitles.length})`;
      };
      r.readAsText(f);
    };

    // Parse SRT into [{start,end,zh,en},...]
    function parseSRT(data) {
      const off = parseFloat(offsetInput.value) || 0;
      const blocks = data.trim().split(/\r?\n\r?\n/);
      const result = [];
      
      console.log('[INFO] Starting SRT parsing, total blocks:', blocks.length);
      
      blocks.forEach((block, blockIndex) => {
        const lines = block.split(/\r?\n/);
        console.log(`[BLOCK ${blockIndex + 1}] Raw content:`, lines);
        
        if (lines.length < 2) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: Not enough lines`);
          return;
        }
        
        // æŸ¥æ‰¾æ—¶é—´è¡Œ
        let timeLineIndex = -1;
        let timeLine = '';
        
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('-->')) {
            timeLineIndex = i;
            timeLine = lines[i];
            break;
          }
        }
        
        if (timeLineIndex === -1) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No time line found`);
          return;
        }
        
        // è§£ææ—¶é—´
        const timeRegex = /(\d+):(\d+):(\d+),(\d+)\s*-->\s*(\d+):(\d+):(\d+),(\d+)/;
        const m = timeLine.match(timeRegex);
        if (!m) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: Invalid time format`);
          return;
        }
        
        const st = +m[1]*3600 + +m[2]*60 + +m[3] + +m[4]/1000 + off;
        const et = +m[5]*3600 + +m[6]*60 + +m[7] + +m[8]/1000 + off;
        
        // è·å–æ‰€æœ‰å­—å¹•å†…å®¹è¡Œï¼ˆä»æ—¶é—´è¡Œä¹‹åå¼€å§‹ï¼‰
        const contentLines = lines.slice(timeLineIndex + 1)
          .filter(line => line.trim()) // è¿‡æ»¤ç©ºè¡Œ
          .filter(line => !line.includes('{\\')) // è¿‡æ»¤ASS/SSAæ ·å¼æ ‡è®°
          .map(line => line.trim());
        
        console.log(`[BLOCK ${blockIndex + 1}] Content lines:`, contentLines);
        
        if (contentLines.length === 0) {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No valid content`);
          return;
        }
        
        let zh = '', en = '';
        
        if (contentLines.length === 1) {
          // å•è¡Œå†…å®¹ï¼šæ£€æµ‹æ˜¯å¦ä¸ºä¸­æ–‡
          const content = contentLines[0];
          if (/[\u4e00-\u9fff]/.test(content)) {
            // åŒ…å«ä¸­æ–‡å­—ç¬¦ï¼Œå½“ä½œä¸­æ–‡
            zh = content;
            en = '';
            console.log(`[BLOCK ${blockIndex + 1}] Chinese only: "${zh}"`);
          } else {
            // çº¯è‹±æ–‡
            zh = '';
            en = content;
            console.log(`[BLOCK ${blockIndex + 1}] English only: "${en}"`);
          }
        } else if (contentLines.length === 2) {
          // åŒè¡Œå†…å®¹ï¼šç¬¬ä¸€è¡Œä¸­æ–‡ï¼Œç¬¬äºŒè¡Œè‹±æ–‡
          const line1 = contentLines[0];
          const line2 = contentLines[1];
          
          if (/[\u4e00-\u9fff]/.test(line1) && !/[\u4e00-\u9fff]/.test(line2)) {
            // ç¬¬ä¸€è¡Œæœ‰ä¸­æ–‡ï¼Œç¬¬äºŒè¡Œæ— ä¸­æ–‡ -> åŒè¯­æ ¼å¼
            zh = line1;
            en = line2;
            console.log(`[BLOCK ${blockIndex + 1}] Bilingual: CN="${zh}" EN="${en}"`);
          } else {
            // å…¶ä»–æƒ…å†µï¼šåˆå¹¶ä¸ºè‹±æ–‡
            zh = '';
            en = contentLines.join(' ');
            console.log(`[BLOCK ${blockIndex + 1}] Merged English: "${en}"`);
          }
        } else {
          // å¤šè¡Œå†…å®¹ï¼šåˆå¹¶ä¸ºè‹±æ–‡
          zh = '';
          en = contentLines.join(' ');
          console.log(`[BLOCK ${blockIndex + 1}] Multi-line English: "${en}"`);
        }
        
        // åªè¦æœ‰å†…å®¹å°±æ·»åŠ 
        if (zh || en) {
          result.push({
            start: st,
            end: et,
            zh: zh,
            en: en
          });
          console.log(`[BLOCK ${blockIndex + 1}] Added: ${st.toFixed(2)}s-${et.toFixed(2)}s`);
        } else {
          console.log(`[BLOCK ${blockIndex + 1}] Skipping: No valid content`);
        }
      });
      
      console.log('[SUCCESS] Parsing complete, total subtitles:', result.length);
      return result;
    }

    // Render subtitles (ä¸­æ–‡å°å­—åœ¨ä¸Šï¼Œè‹±æ–‡å¤§å­—åœ¨ä¸‹)
    function renderSubtitles() {
      subtitlesDiv.innerHTML = '';
      console.log('Rendering subtitles, total:', subtitles.length);
      
      subtitles.forEach((sub, i) => {
        console.log(`Subtitle ${i+1}: CN="${sub.zh}", EN="${sub.en}"`);
        
        const div = document.createElement('div');
        div.className = 'subtitle-line';
        
        // æ ¹æ®æ˜¯å¦æœ‰ä¸­æ–‡å†…å®¹å†³å®šæ˜¾ç¤ºæ–¹å¼
        if (sub.zh) {
          // åŒè¯­å­—å¹•ï¼šä¸­æ–‡åœ¨ä¸Šï¼Œè‹±æ–‡åœ¨ä¸‹
          div.innerHTML = `
            <p style="margin:0;color:#880e4f;font-size:12px;line-height:1.3;">${sub.zh}</p>
            <p style="margin:4px 0 0;color:#333;font-size:24px;font-weight:500;line-height:1.2;">${sub.en}</p>
          `;
        } else {
          // çº¯è‹±æ–‡å­—å¹•ï¼šåªæ˜¾ç¤ºè‹±æ–‡
          div.innerHTML = `
            <p style="margin:0;color:#333;font-size:24px;font-weight:500;line-height:1.2;">${sub.en}</p>
          `;
        }
        
        div.onclick = () => jump(i);
        subtitlesDiv.appendChild(div);
      });
    }

    // Seek & highlight
    function jump(idx) {
      if (idx < 0 || idx >= subtitles.length) {
        console.log(`[JUMP] Invalid index: ${idx}, valid range: 0-${subtitles.length-1}`);
        return;
      }
      
      console.log(`[JUMP] Jumping to subtitle ${idx+1}`);
      currentIndex = idx;
      video.currentTime = subtitles[idx].start;
      video.play().catch(err => console.log('[ERROR] Play failed:', err));
      highlight();
      
      // å¾ªç¯æ¨¡å¼ä¸‹ï¼šåˆ‡æ¢åˆ°æ–°å¥å­åç«‹å³å¼€å§‹å¾ªç¯
      if (loopMode) {
        console.log(`[LOOP] Sticking to subtitle ${idx+1} in loop mode`);
        statusDiv.textContent = `ğŸ”„ Sticky loop mode: Subtitle ${idx + 1}`;
      }
    }

    function highlight() {
      const lines = subtitlesDiv.querySelectorAll('.subtitle-line');
      lines.forEach((el,i)=>el.classList.toggle('active', i===currentIndex));
      const active = lines[currentIndex];
      if (active) active.scrollIntoView({behavior:'smooth', block:'center'});

      // Video overlay: æ ¹æ®å­—å¹•ç±»å‹æ˜¾ç¤º
      if (currentIndex >= 0 && currentIndex < subtitles.length) {
        const sub = subtitles[currentIndex];
        
        if (sub.zh) {
          // åŒè¯­å­—å¹•ï¼šä¸­æ–‡åœ¨ä¸Š(å°å­—)ï¼Œè‹±æ–‡åœ¨ä¸‹(å¤§å­—)
          currentSub.innerHTML = `
            <div style="line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.8);">
              <div style="font-size:${Math.floor(fontSize*0.6)}px; color:#f8bbd0;">${sub.zh}</div>
              <div style="font-size:${fontSize}px; color:#fff; font-weight:500;">${sub.en}</div>
            </div>
          `;
        } else {
          // çº¯è‹±æ–‡å­—å¹•ï¼šåªæ˜¾ç¤ºè‹±æ–‡
          currentSub.innerHTML = `
            <div style="line-height:1.2; text-shadow:0 2px 4px rgba(0,0,0,0.8);">
              <div style="font-size:${fontSize}px; color:#fff; font-weight:500;">${sub.en}</div>
            </div>
          `;
        }
      }
    }

    video.ontimeupdate = () => {
      const t = video.currentTime;
      
      // ğŸ”„ å¾ªç¯æ¨¡å¼ï¼šALWAYSå¾ªç¯å½“å‰å¥å­ï¼Œä¸ç®¡æ€ä¹ˆåˆ‡æ¢
      if (loopMode && currentIndex >= 0 && currentIndex < subtitles.length) {
        const currentSub = subtitles[currentIndex];
        
        // å½“å‰å¥å­æ’­æ”¾ç»“æŸæ—¶ï¼Œç«‹å³è·³å›å¼€å§‹ç»§ç»­å¾ªç¯
        if (t >= currentSub.end - 0.05) {
          console.log(`[LOOP] End detected: ${t.toFixed(2)} >= ${currentSub.end.toFixed(2)}, jumping to start ${currentSub.start.toFixed(2)}`);
          video.currentTime = currentSub.start;
          return; // å¾ªç¯è·³è½¬åä¸æ‰§è¡Œå…¶ä»–é€»è¾‘
        }
        
        // å¾ªç¯æ¨¡å¼ä¸‹ï¼šå¦‚æœæ’­æ”¾ä½ç½®ä¸åœ¨å½“å‰å¥å­èŒƒå›´å†…ï¼Œå¼ºåˆ¶è·³å›
        if (t < currentSub.start - 0.2 || t > currentSub.end + 0.2) {
          console.log(`[LOOP] Out of range: current=${t.toFixed(2)}, valid=${currentSub.start.toFixed(2)}-${currentSub.end.toFixed(2)}, forcing return`);
          video.currentTime = currentSub.start;
          return;
        }
      } else {
        // æ­£å¸¸æ¨¡å¼ï¼šè‡ªåŠ¨è·Ÿéšå­—å¹•
        const idx = subtitles.findIndex(s=>t>=s.start&&t<s.end);
        if (idx!==-1 && idx!==currentIndex) {
          console.log(`[AUTO] Changing subtitle to ${idx+1}`);
          currentIndex = idx;
          highlight();
        }
      }
    };

    // Controls
    prevBtn.onclick  = () => jump(Math.max(0, currentIndex-1));
    nextBtn.onclick  = () => jump(Math.min(subtitles.length-1, currentIndex+1));
    playBtn.onclick  = () => {
      video.play();
      if (loopMode && currentIndex >= 0) {
        statusDiv.textContent = `ğŸ”„ Sticky loop mode: Subtitle ${currentIndex + 1}`;
      } else {
        statusDiv.textContent = 'â–¶ï¸ Playing...';
      }
    };
    pauseBtn.onclick = () => {
      if (video.paused) {
        video.play();
        if (loopMode && currentIndex >= 0) {
          statusDiv.textContent = `ğŸ”„ Sticky loop mode: Subtitle ${currentIndex + 1}`;
        } else {
          statusDiv.textContent = 'â–¶ï¸ Playing...';
        }
      } else {
        video.pause();
        statusDiv.textContent = 'â¸ï¸ Paused';
      }
    };
    loopBtn.onclick  = () => {
      loopMode = !loopMode;
      
      console.log(`[LOOP] Loop mode ${loopMode ? 'ENABLED' : 'DISABLED'}`);
      
      if (loopMode) {
        // ğŸ”„ å¼€å¯ç²˜æ€§å¾ªç¯æ¨¡å¼ - ç®€æ´æ·±è‰²åŠ ç²—æ•ˆæœ
        loopBtn.style.backgroundColor = '#d81b60'; // æ›´æ·±çš„ç²‰è‰²
        loopBtn.style.fontWeight = 'bold';
        loopBtn.style.transform = 'none';
        loopBtn.style.boxShadow = 'none';
        loopBtn.innerHTML = '&#x27F3;'; // ä¿æŒä¸€è‡´çš„å›¾æ ‡
        
        if (currentIndex >= 0 && currentIndex < subtitles.length) {
          // è·³è½¬åˆ°å½“å‰å­—å¹•çš„å¼€å§‹ä½ç½®
          console.log(`[LOOP] Resetting current subtitle ${currentIndex+1} to start time`);
          video.currentTime = subtitles[currentIndex].start;
          statusDiv.textContent = `ğŸ”„ Loop mode: Subtitle ${currentIndex + 1}`;
        } else {
          statusDiv.textContent = 'ğŸ”„ Loop mode enabled';
        }
      } else {
        // å…³é—­å¾ªç¯æ¨¡å¼ - æ¢å¤æ­£å¸¸çŠ¶æ€
        loopBtn.style.backgroundColor = '#ff6eb4'; // åŸæ¥çš„ç²‰è‰²
        loopBtn.style.fontWeight = 'normal';
        loopBtn.style.transform = 'none';
        loopBtn.style.boxShadow = 'none';
        loopBtn.innerHTML = '&#x27F3;';
        statusDiv.textContent = 'Loop mode disabled';
      }
    };
    increaseBtn.onclick = ()=>{
      fontSize += 2;
      currentSub.style.fontSize = fontSize+'px';
    };
    decreaseBtn.onclick = ()=>{
      if (fontSize>10) fontSize -= 2, currentSub.style.fontSize = fontSize+'px';
    };

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      // é˜²æ­¢åœ¨è¾“å…¥æ¡†ä¸­è§¦å‘
      if (e.target.tagName === 'INPUT') return;
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          // ä¸Šä¸€å¥
          if (currentIndex > 0) {
            jump(currentIndex - 1);
          }
          break;
        case 'ArrowDown':
          e.preventDefault();
          // ä¸‹ä¸€å¥
          if (currentIndex < subtitles.length - 1) {
            jump(currentIndex + 1);
          }
          break;
        case ' ':
          e.preventDefault();
          // ç©ºæ ¼é”®æ’­æ”¾/æš‚åœåˆ‡æ¢
          if (video.paused) {
            video.play();
            if (loopMode && currentIndex >= 0) {
              statusDiv.textContent = `ğŸ”„ Sticky loop mode: Subtitle ${currentIndex + 1}`;
            } else {
              statusDiv.textContent = 'â–¶ï¸ Playing...';
            }
          } else {
            video.pause();
            statusDiv.textContent = 'â¸ï¸ Paused';
          }
          break;
      }
    });

    // æ·»åŠ å›è½¦é”®æœç´¢åŠŸèƒ½
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchBtn.click();
      }
    });

    // é‡å†™æœç´¢åŠŸèƒ½ - å…ˆæœ¬åœ°è¯å…¸ï¼ŒåAPI
    searchBtn.onclick = function() {
      const word = searchInput.value.trim().toLowerCase();
      if (!word) return;
      
      console.log(`[SEARCH] æœç´¢å•è¯: "${word}"`);
      
      // æ˜¾ç¤ºåŠ è½½æç¤º
      translationDiv.innerHTML = `<div style=\"margin-bottom:10px;\"><p>ğŸ” æ­£åœ¨æŸ¥è¯¢...</p></div>`;
      
      // ä¼˜å…ˆæœ¬åœ°è¯å…¸
      if (commonWords[word]) {
        showTranslation(word, commonWords[word], phonetics[word] || "");
        return;
      }
      // æœ¬åœ°æ²¡æœ‰ï¼Œå°è¯•åœ¨çº¿API
      // å…ˆMyMemoryï¼Œå†DictionaryAPI
      fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|zh-CN`)
        .then(res => res.json())
        .then(data => {
          let translation = '';
          if (data && data.responseData && data.responseData.translatedText) {
            translation = data.responseData.translatedText;
            if (translation.includes('MyMemory')) {
              translation = translation.split('MyMemory')[0].trim();
            }
          }
          if (translation && translation !== word) {
            showTranslation(word, [translation], '');
          } else {
            // å†è¯• DictionaryAPI
            fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
              .then(r => r.json())
              .then(dictData => {
                let phonetic = '';
                let defs = [];
                if (Array.isArray(dictData) && dictData.length > 0) {
                  if (dictData[0].phonetics && dictData[0].phonetics.length > 0) {
                    const p = dictData[0].phonetics.find(x => x.text);
                    if (p) phonetic = p.text;
                  }
                  if (dictData[0].meanings && dictData[0].meanings.length > 0) {
                    dictData[0].meanings.forEach(m => {
                      if (m.definitions && m.definitions.length > 0) {
                        defs.push(m.definitions[0].definition);
                      }
                    });
                  }
                }
                if (defs.length > 0) {
                  showTranslation(word, defs, phonetic);
                } else {
                  showTranslation(word, [], phonetic);
                }
              })
              .catch(() => showTranslation(word, [], ''));
          }
        })
        .catch(() => {
          // APIå¤±è´¥ï¼Œç›´æ¥æ˜¾ç¤ºæ— ç»“æœ
          showTranslation(word, [], '');
        });
    };

    // å±•ç¤ºç¿»è¯‘å’ŒéŸ³æ ‡ï¼Œè°ƒæ•´è¡Œé—´è·
    function showTranslation(word, translations, phonetic) {
      let result = `<div style=\"padding:15px;\">`;
      result += `<div style=\"display:flex;align-items:center;margin-bottom:10px;\">
        <h3 style=\"margin:0;font-size:22px;color:#d81b60;\">${word}</h3>
        <span style=\"margin-left:10px;color:#666;font-size:15px;\">${phonetic || ''}</span>
        <button id=\"pronounceBtn\" style=\"margin-left:auto;background:#9c27b0;color:white;border:none;padding:5px 10px;border-radius:4px;cursor:pointer;\">
          ğŸ”Š å‘éŸ³
        </button>
      </div>`;
      result += `<h4 style=\"margin:0 0 8px 0;color:#d81b60;font-size:15px;\">ä¸­æ–‡è§£é‡Š:</h4>`;
      if (translations && translations.length > 0) {
        result += `<ol style=\"margin:0;padding-left:22px;line-height:1.5;\">`;
        translations.forEach(function(trans) {
          result += `<li style=\"margin-bottom:5px;font-size:15px;font-weight:500;line-height:1.5;\">${trans}</li>`;
        });
        result += `</ol>`;
      } else {
        result += `<p style=\"color:#666;line-height:1.5;\">æœªæ‰¾åˆ°\"${word}\"çš„å¸¸ç”¨ç¿»è¯‘å’ŒéŸ³æ ‡ã€‚</p>`;
        result += `<p style=\"color:#666;font-size:13px;line-height:1.5;\">æç¤ºï¼šå°è¯•æœç´¢å¸¸ç”¨å•è¯ï¼Œå¦‚ run, get, make, take ç­‰ã€‚</p>`;
      }
      result += `</div>`;
      translationDiv.innerHTML = result;
      document.getElementById('pronounceBtn').onclick = function() {
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        speechSynthesis.speak(utterance);
      };
    }

    // å¸¸ç”¨è‹±è¯­å•è¯è¯å…¸æ•°æ®
    const commonWords = {
      "run": ["è·‘ï¼Œå¥”è·‘", "è¿è¡Œï¼Œå¼€åŠ¨", "ç®¡ç†ï¼Œç»è¥"],
      "set": ["è®¾ç½®ï¼Œæ”¾ç½®", "ä¸€å¥—ï¼Œä¸€ç»„", "å›ºå®šçš„ï¼Œä¸å˜çš„"],
      "go": ["å»ï¼Œç¦»å¼€", "è¿›è¡Œï¼Œè¿›å±•", "å°è¯•ï¼ŒåŠªåŠ›"],
      "make": ["åˆ¶ä½œï¼Œåˆ›é€ ", "ä½¿å¾—ï¼Œä¿ƒä½¿", "è·å¾—ï¼Œèµšå¾—"],
      "take": ["æ‹¿ï¼Œå–", "æ¥å—", "èŠ±è´¹ï¼ˆæ—¶é—´ï¼‰"],
      "come": ["æ¥ï¼Œæ¥åˆ°", "å‡ºç°", "å‘ç”Ÿ"],
      "get": ["å¾—åˆ°ï¼Œè·å¾—", "å˜å¾—", "åˆ°è¾¾"],
      "give": ["ç»™äºˆ", "é€’ç»™", "ä¸¾è¡Œï¼Œä¸¾åŠ"],
      "see": ["çœ‹è§", "ç†è§£", "æ‹œè®¿"],
      "look": ["çœ‹ï¼Œæ³¨è§†", "çœ‹èµ·æ¥", "å¯»æ‰¾"],
      "find": ["å‘ç°", "æŸ¥æ˜", "æ„Ÿè§‰ï¼Œè®¤ä¸º"],
      "say": ["è¯´", "è¡¨è¾¾", "å‡è®¾"],
      "use": ["ä½¿ç”¨", "æ¶ˆè€—", "ä¹ æƒ¯"],
      "tell": ["å‘Šè¯‰", "è¾¨åˆ«", "å‘½ä»¤"],
      "work": ["å·¥ä½œ", "è¿è½¬", "èµ·ä½œç”¨"],
      "call": ["æ‰“ç”µè¯", "å«å–Š", "å‘½å"],
      "try": ["å°è¯•", "è¯•å›¾", "å®¡åˆ¤"],
      "ask": ["é—®", "è¦æ±‚", "é‚€è¯·"],
      "need": ["éœ€è¦", "å¿…é¡»", "è´«å›°"],
      "feel": ["æ„Ÿè§‰", "æ‘¸ï¼Œè§¦", "è®¤ä¸º"],
      "read": ["é˜…è¯»", "ç†è§£", "æ˜¾ç¤ºï¼ˆæ•°å€¼ï¼‰"],
      "put": ["æ”¾ï¼Œç½®", "è¡¨è¾¾", "æå‡º"],
      "play": ["ç©", "æ’­æ”¾", "æ¼”å¥"],
      "move": ["ç§»åŠ¨", "æ¬å®¶", "æ„ŸåŠ¨"],
      "help": ["å¸®åŠ©", "æ”¹å–„", "é¿å…"],
      "talk": ["è°ˆè¯", "è®¨è®º", "æ¼”è®²"],
      "turn": ["è½¬åŠ¨", "å˜æˆ", "è½®æµ"],
      "start": ["å¼€å§‹", "åˆ›åŠ", "å¯åŠ¨"],
      "show": ["å±•ç¤º", "è¡¨æ˜", "è¯æ˜"],
      "hear": ["å¬è§", "å¾—çŸ¥", "å®¡ç†"],
      "walk": ["æ­¥è¡Œ", "é›ï¼ˆç‹—ï¼‰", "æ¼«æ­¥"],
      "write": ["å†™", "å†™ä½œ", "å¼€ï¼ˆæ”¯ç¥¨ç­‰ï¼‰"],
      "sit": ["å", "æ‹…ä»»", "å¼€ä¼š"],
      "stand": ["ç«™ç«‹", "ä½äº", "å¿å—"],
      "lose": ["å¤±å»", "è¾“æ‰", "é”™è¿‡"],
      "pay": ["ä»˜æ¬¾", "ç»™äºˆ", "å€¼å¾—"],
      "meet": ["é‡è§", "æ»¡è¶³", "è¿æ¥"],
      "drive": ["é©¾é©¶", "é©±ä½¿", "å¼€è½¦é€"],
      "stop": ["åœæ­¢", "é˜»æ­¢", "é€—ç•™"],
      "follow": ["è·Ÿéš", "éµå¾ª", "ç†è§£"],
      "learn": ["å­¦ä¹ ", "å¾—çŸ¥", "è®°ä½"],
      "speak": ["è¯´è¯", "æ¼”è®²", "è¡¨è¾¾"],
      "let": ["è®©", "å…è®¸", "å‡ºç§Ÿ"],
      "keep": ["ä¿æŒ", "ç»§ç»­", "é¥²å…»"],
      "leave": ["ç¦»å¼€", "é—ç•™", "å§”æ‰˜"],
      "break": ["æ‰“ç ´", "ä¼‘æ¯", "çªç ´"],
      "like": ["å–œæ¬¢", "åƒï¼Œå¦‚åŒ", "ä¾‹å¦‚"],
      "think": ["æ€è€ƒ", "è®¤ä¸º", "æƒ³è±¡"],
      "want": ["æƒ³è¦", "éœ€è¦", "ç¼ºä¹"],
      "open": ["æ‰“å¼€", "å¼€å§‹", "å¦ç‡çš„"],
      "close": ["å…³é—­", "é è¿‘", "ç»“æŸ"],
      "good": ["å¥½çš„", "æœ‰ç›Šçš„", "ç†Ÿç»ƒçš„"],
      "bad": ["åçš„", "æœ‰å®³çš„", "ä¸èˆ’æœçš„"],
      "big": ["å¤§çš„", "é‡è¦çš„", "æˆåŠŸçš„"],
      "small": ["å°çš„", "ä¸é‡è¦çš„", "ç‹­çª„çš„"],
      "high": ["é«˜çš„", "é«˜çº§çš„", "é«˜ä»·çš„"],
      "low": ["ä½çš„", "ä½çº§çš„", "ä½ä»·çš„"],
      "long": ["é•¿çš„", "æŒä¹…çš„", "å†—é•¿çš„"],
      "short": ["çŸ­çš„", "ç®€æ´çš„", "ç¼ºä¹çš„"],
      "hard": ["ç¡¬çš„", "å›°éš¾çš„", "åŠªåŠ›åœ°"],
      "easy": ["å®¹æ˜“çš„", "èˆ’é€‚çš„", "éšå’Œçš„"],
      "fast": ["å¿«çš„", "è¿…é€Ÿçš„", "åšå›ºçš„"],
      "slow": ["æ…¢çš„", "ç¼“æ…¢çš„", "è¿Ÿé’çš„"],
      "hot": ["çƒ­çš„", "è¾£çš„", "æµè¡Œçš„"],
      "cold": ["å†·çš„", "å†·æ·¡çš„", "æ„Ÿå†’"],
      "new": ["æ–°çš„", "æœ€è¿‘çš„", "ä¸ç†Ÿæ‚‰çš„"],
      "old": ["æ—§çš„", "å¹´è€çš„", "å¤è€çš„"],
      "right": ["æ­£ç¡®çš„", "å³è¾¹çš„", "æƒåˆ©"],
      "wrong": ["é”™è¯¯çš„", "ä¸é€‚å½“çš„", "ä¸å…¬æ­£çš„"],
      "early": ["æ—©çš„", "æå‰çš„", "åˆæœŸçš„"],
      "late": ["æ™šçš„", "è¿Ÿåˆ°çš„", "å·²æ•…çš„"],
      "strong": ["å¼ºå£®çš„", "å¼ºçƒˆçš„", "åšå›ºçš„"],
      "weak": ["å¼±çš„", "è™šå¼±çš„", "ç¨€è–„çš„"],
      "happy": ["å¿«ä¹çš„", "æ»¡æ„çš„", "å¹¸è¿çš„"],
      "sad": ["æ‚²ä¼¤çš„", "ä»¤äººå¤±æœ›çš„", "éš¾è¿‡çš„"]
    };

    // æ·»åŠ éŸ³æ ‡æ•°æ®
    const phonetics = {
      "run": "/rÊŒn/",
      "set": "/set/",
      "go": "/É¡É™ÊŠ/",
      "make": "/meÉªk/",
      "take": "/teÉªk/",
      "come": "/kÊŒm/",
      "get": "/É¡et/",
      "give": "/É¡Éªv/",
      "see": "/siË/",
      "look": "/lÊŠk/",
      "find": "/faÉªnd/",
      "say": "/seÉª/",
      "use": "/juËz/",
      "tell": "/tel/",
      "work": "/wÉœËk/",
      "call": "/kÉ”Ël/",
      "try": "/traÉª/",
      "ask": "/É‘Ësk/",
      "need": "/niËd/",
      "feel": "/fiËl/",
      "read": "/riËd/",
      "put": "/pÊŠt/",
      "play": "/pleÉª/",
      "move": "/muËv/",
      "help": "/help/",
      "talk": "/tÉ”Ëk/",
      "turn": "/tÉœËn/",
      "start": "/stÉ‘Ët/",
      "show": "/ÊƒÉ™ÊŠ/",
      "hear": "/hÉªÉ™/",
      "walk": "/wÉ”Ëk/",
      "write": "/raÉªt/",
      "sit": "/sÉªt/",
      "stand": "/stÃ¦nd/",
      "lose": "/luËz/",
      "pay": "/peÉª/",
      "meet": "/miËt/",
      "drive": "/draÉªv/",
      "stop": "/stÉ’p/",
      "follow": "/ËˆfÉ’lÉ™ÊŠ/",
      "learn": "/lÉœËn/",
      "speak": "/spiËk/",
      "let": "/let/",
      "keep": "/kiËp/",
      "leave": "/liËv/",
      "break": "/breÉªk/",
      "like": "/laÉªk/",
      "think": "/Î¸ÉªÅ‹k/",
      "want": "/wÉ’nt/",
      "open": "/ËˆÉ™ÊŠpÉ™n/",
      "close": "/klÉ™ÊŠz/",
      "good": "/É¡ÊŠd/",
      "bad": "/bÃ¦d/",
      "big": "/bÉªÉ¡/",
      "small": "/smÉ”Ël/",
      "high": "/haÉª/",
      "low": "/lÉ™ÊŠ/",
      "long": "/lÉ’Å‹/",
      "short": "/ÊƒÉ”Ët/",
      "hard": "/hÉ‘Ëd/",
      "easy": "/ËˆiËzi/",
      "fast": "/fÉ‘Ëst/",
      "slow": "/slÉ™ÊŠ/",
      "hot": "/hÉ’t/",
      "cold": "/kÉ™ÊŠld/",
      "new": "/njuË/",
      "old": "/É™ÊŠld/",
      "right": "/raÉªt/",
      "wrong": "/rÉ’Å‹/",
      "early": "/ËˆÉœËli/",
      "late": "/leÉªt/",
      "strong": "/strÉ’Å‹/",
      "weak": "/wiËk/",
      "happy": "/ËˆhÃ¦pi/",
      "sad": "/sÃ¦d/"
    };
  </script>
</body>
</html> 